function varargout = bh_z_calc_util(L_1, L_2, L_3, L_4, theta, action_str)
% ALLOWED USAGE:
% >>  [the_z, the_num, the_den] = bh_z_calc_util(L_1, L_2, L_3, L_4, theta, "CALC_Z");

[z_sol, the_num, the_den]   = bh_z_func(L_1, L_2, L_3, L_4, theta);

% now look for "fringe" cases where the numeric solution is a VERY
% VERY small complex number
%-------------------------------------------------------------------------
% BH_18_07_2019:  No
[z_sol, the_num, the_den] = LOC_fringe_correction(z_sol, the_num, the_den);
%-------------------------------------------------------------------------
 
 % now take care of the OUTPUTS
   switch(upper(action_str))
       case "CALC_Z"
            varargout{1} = [z_sol(1); z_sol(2)];          % z
            varargout{2} = [  the_num(1);   the_num(2)];  % the_num
            varargout{3} = [  the_den(1);   the_den(2)];  % the_den
       otherwise
          error("ERROR:  unknown action string !");     
   end
end
%_-------------------------------------------------------------------------
function [z_sol, num_sol, den_sol] = LOC_fringe_correction(z_in, num_in, den_in)

     SMALL_NUMBER        = 1e-6;  
       
     z_sol   = zeros(size(z_in));
     num_sol = zeros(size(num_in));
     den_sol = zeros(size(den_in));
     
    for kk=1:length(z_in)
        the_z   = z_in(kk);
        the_num = num_in(kk);
        the_den = den_in(kk);
        
        if( isreal(the_z) )
              z_sol(kk,1) = the_z;
            num_sol(kk,1) = the_num; 
            den_sol(kk,1) = the_den;
        else % z is a COMPLEX number
            
            the_num_iMAG = abs(imag(the_num));
            the_den_MAG  = abs(the_den);
            
            if( the_num_iMAG <= SMALL_NUMBER  &&  the_den_MAG > SMALL_NUMBER)
                % so we have a VERY small imaginary component
                num_sol(kk,1) = real(the_num); 
                den_sol(kk,1) = the_den;
                z_sol(kk,1)   = num_sol(kk,1)/den_sol(kk,1);
            else
                % a complex number with a large IMAGINARY component
                  z_sol(kk,1) = the_z;
                num_sol(kk,1) = the_num; 
                den_sol(kk,1) = the_den;
            end            
        end % if(isreal)
    end % FOR
end % function LOC_fringe_correction
%_#########################################################################
function [the_z,the_num,the_den] = bh_z_func(L_1,L_2,L_3,L_4,theta)
%BH_Z_FUNC
%    [THE_Z,THE_NUM,THE_DEN] = BH_Z_FUNC(L_1,L_2,L_3,L_4,THETA)

%    This function was generated by the Symbolic Math Toolbox version 8.3.
%    02-Jul-2019 08:53:05

t2 = cos(theta);
t3 = sin(theta);
t4 = L_1.^2;
t5 = L_2.^2;
t6 = L_3.^2;
t7 = L_4.^2;
t8 = L_2.*L_3.*2.0;
t9 = L_3.*L_4.*2.0;
t10 = -t9;
t11 = -t4;
t12 = -t5;
t13 = -t6;
t14 = -t7;
t15 = L_1.*L_3.*t2.*2.0;
t16 = L_1.*L_4.*t2.*2.0;
t17 = L_1.*L_3.*t3.*2.0;
t18 = -t16;
t19 = t5+t6+t8+t11+t14+t16;
t20 = t4+t7+t8+t12+t13+t18;
t21 = t4+t6+t7+t10+t12+t15+t18;
t22 = 1.0./t21;
t23 = t19.*t20;
t24 = sqrt(t23);
t25 = t17+t24;
the_z = [t22.*t25;t22.*(t17-t24)];
if nargout > 1
    the_num = [t25;t17-t24];
end
if nargout > 2
    the_den = [t21;t21];
end
end
%--------------------------------------------------------------------------